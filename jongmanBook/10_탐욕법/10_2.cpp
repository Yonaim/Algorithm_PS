// 10.2 출전 순서 정하기 문제를 해결하는 탐욕법 알고리즘

/*
문제 접근

    무식하게 풀기(완전탐색)
    -> n!개의 순열을 만들고 전부 확인해야함. 너무 많다

    동적 계획법
    -> 선수의 선택 현황을 나타내는 boolean 배열을 사용하여 하나의 부분 문제를 정의한다.
        winCount(int selectCnt, bool *player): player 중 selectCnt만큼 선택되었고 선택 현황이 player일 때 남은 선수들을
배치하여 얻을 수 있는 최대 승리 횟수 (사실 책에 나온 것처럼 selectCnt는 없어도 되긴 함...) 부분 문제의 수 2^n개, 하나의
부분 문제를 푸는데 걸리는 시간 n(다음 선수의 선택을 위해 깊이가 1인 반복문 사용) 따라서 시간복잡도는 대강 O(2^n * n)이
된다.
*/

/*
책 다 읽긴했는데 솔직히 말해서 정당성 증명 부분(373~374p)이 잘 이해되지 않는다.
어? 이렇게 해도 증명이 되나? 하는 느낌...

일단 '우리가 선택한 방법을 포함하지 않는 최적해를 가정' 이 부분부터가 잘 이해가 안되었는데...
음...'최적해를 향한 선택이 여러가지가 존재할 수 있는' 상황에서 '우리의 선택' 또한 최적해임을 보이기 위한 가정같다.
*/

/*
탐욕 알고리즘 증명

한국 선수들 중 A와 B가 있고 A < B라고 해보자.

1. 경기를 질 수밖에 없는 경우
    - 한국 선수들이 전부 이 상대 선수보다 레이팅이 낮은 경우에 해당.
    - 어차피 질 수밖에 없으므로 고안한 알고리즘대로면, 가장 레이팅이 낮은 A를 내보내면 된다.
    - 근데 A보다 레이팅이 높은 B를 내보냈을 때 최적해가 존재한다고 가정한다면?
        어차피 둘다 지는 상황이므로 A를 내보내건 B를 내보내건 둘다 최적해이다.

2. 경기를 이길 수 있는 경우
    - 한국 선수들 중 이 상대 선수를 이길 수 있는 선수가 존재하는 경우에 해당.
    - A와 B가 모두 이 선수를 이길 수 있는 상황이라고 할 때, 고안한 알고리즘대로면 '이길 수 있는 선수들 중 가장 레이팅이
낮은' A를 내보내야한다.
    - 근데 A보다 레이팅이 높은 B를 내보냈을 때 최적해가 존재한다고 가정한다면?
        어차피 둘다 이기는 상황이므로 A를 내보내건 B를 내보내건 둘다 최적해이다.
    - 근데~~~ '이길 수 있는' 경우니까, 이기지 않는 선수를 내보낼 수도 있을 것이다. 그런 상황일때도 최적해가 있다고
가정해봐야한다. A보다도 레이팅이 낮아 이 상대 선수에게 '이길 수 없는' F라는 선수가 있다고 해보자. 그리고 이 경기에서 F를
내보냈을 때 최적해가 있다고 가정한다. F를 내보내면 이 경기는 지게 될 것이다. 만약 F 대신에 A를 내보내면 이 경기는
이긴다. 승리 횟수가 1 올라간다 (단, 'F를 내보냈을 때 최적해가 있다'라고 가정했으므로 A를 내보내면 F를 내보냈을 때에 비해
나머지 경기 중 지는 경기가 하나 있을 것이다)

... 이렇게 생각할 수 있는 모든 경우에서 고안한 알고리즘대로 선택을 변경하더라도 여전히 최적해임을 알 수 있다.

*/

#include <set>
#include <vector>

using namespace std;

int order(const vector<int> &korean, const vector<int> &russian)
{
    int n = russian.size();
    int win = 0;

    multiset<int> ratings(korean.begin(), korean.end());
    for (int i = 0; i < n; i++)
    {
        if (*ratings.rbegin() < russian[i])
            // 남은 선수들 중 가장 레이팅이 높은 선수와 상대 선수의 레이팅을 비교해서 이 경기를 이길 수 있는지 확인
            ratings.erase(ratings.begin());
        // 아무도 상대 선수에게 이길 수 없으므로 가장 레이팅이 낮은 선수를 내보낸다
        else
        {
            ratings.erase(ratings.lower_bound(russian[i]));
            // 이길 수 있는 선수 중 가장 레이팅이 낮은 선수를 내보낸다
            win++;
        }
    }
    return (win);
}