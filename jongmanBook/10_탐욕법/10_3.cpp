// 10.3 도시락 데우기 문제를 해결하는 탐욕적 알고리즘

// 이러한 스케줄링 문제는 대게 탐욕법으로 풀린다?

/*
알고리즘 구상

모든 도시락을 먹는 시간이 같다고 가정해본다.
그러면 모든 도시락을 데우고, 먹는데 걸리는 시간은
    = (각 도시락을 데우는 시간의 합) + (마지막에 데운 하나의 도시락을 먹는 시간)
이 된다.

그렇지만 우리가 풀어야하는 문제는 각 도시락을 먹는데 걸리는 시간이 다 다르다.
이런 점에서 모든 도시락들 중 먹는 시간이 좀더 걸리는 도시락 A가 있다고 할 때, 직관적으로 생각해봤을 때는 A를 먼저 데우는
게 좋을 것 같다. 어차피 모든 도시락을 데우고 먹어야한다는 사실은 이미 정해져있으니, 도시락을 데우는 시간의 합은 고정이고
거기에 마지막에 데운 도시락을 먹는 시간이 추가되기 때문이다.

데우는 시간과는 관계없이 먹는데 걸리는 시간만을 따져서 도시락 돌리는 순서를 정해도 되는걸까???
*/

/*
알고리즘 정당성 증명 - 먹는 시간이 오래 걸리는 도시락부터 데운다?

어떤 도시락 A, B가 있고 B가 A보다 먹는 시간이 좀더 오래 걸린다고 가정해보자. (B > A)
A를 B보다 먼저 돌리는 최적해가 있다고 가정할 때, 순서를 바꿔도 최적해임을 보이면 증명할 수 있다.

아니 근데 ...책 풀이보면 그렇구나~하고 이해는 되는데
난 처음에 책에서 나온 것처럼 0번째와 x번째에 데우는 시간이 다른 도시락을 두지 않고, 'n번째에 A 혹은 B' 이리 생각을 했단
말이다... 후자처럼 생각하면 안되는건가??? (사실 n번째라고 생각을 하더라도 0~n-1번째까지의 도시락은 어차피 신경 안
써도되기에 0번째와 다를바 없다)

무튼 간에...
n번째와 x번째(n!=0, x>n)이라고 생각할 수도 있지만 앞서 언급했다시피 n번째더라도 어차피 앞에 있는 도시락들은
신경을 안 써도되기에 0번째와 다를바 없어서 0번째라고 하겠다.

    - 0번째 A, x번째 B <- 최적해 (가정)
    - 0번째 B, x번째 A <- 최적해? 확인해봐야한다.
(A, B 이외에 도시락 순서는 같음)

x번째까지 데우는 도시락의 종류는 모두 같으므로 도시락 데우는 시간의 총합은 똑같다.
그러므로 x+1번째 도시락부터는 데우고, 먹는 시각이 똑같다. (x번째 도시락은 포함하지 않는다!!! x+1번째 도시락부터
말하는거다)

그럼 0~x번째 도시락만 고려해야한다는 것은 알았다.

0번째 A, x번째 B일때 걸리는 시간의 총합 = (도시락을 데우는 시간의 합) + (B를 먹는 시간)
0번째 B, x번째 A일때 걸리는 시간의 총합 = (도시락을 데우는 시간의 합) + (A를 먹는 시간)

후자가 전자보다 더 값이 클 수는 없다. 따라서 후자도 최적해다.
    (근데 이미 전자가 최적해라고 가정한 상태인데...두 값이 같은 상황이 언제지????)
    (379p 하단을 봐도 x번째 도시락과 y번째 도시락이 먹는데 걸리는 시간이 같아야지 두 값이 같지 않나싶은데...
    그럼 이건 처음 전제에 위배되는 거 아닌가? B가 A보다 더 먹는 시간이 오래 걸린다고 전제를 깔아둬서...뭐징?)

*/

/*
아래는 인터넷 풀이 참고한거

모든 도시락은 무조건 1번씩 다 데워져야 되기 때문에 데우는 시간은 똑같다.
문제는 먹는 시간인데 먹는 시간이 오래걸리는 순서대로 데워서 바로 먹는 그리디 알고리즘을 이용하면 문제를 해결할 수 있다.

정당성 증명
    최적해중에 먹는 시간이 오래걸리는 도시락을 비교적 덜걸리는 도시락보다 더 늦게 먹는 경우가 있다고 가정하자.
    이때 두 도시락의 데우는 순서를 바꾸면 최적해 이하의 시간이 걸린다.
    따라서 먹는 시간이 오래걸리는 순서대로 데워서 먹는 그리디 알고리즘의 정당성이 성립한다.

부분구조증명
    첫번째 도시락을 정했을 때, 나머지 도시락들에 대한 시간도 최소화 해야하므로 성립한다.
*/

#include <string>
#include <vector>

using namespace std;

const int MAX_N = 10000;
int n;
int e[MAX_N]; // 먹는데 걸리는 시간
int m[MAX_N]; // 데우는데 걸리는 시간

int TotalTimeOfheatAndEat()
{
    vector<pair<int, int>> order;
    for (int i = 0; i < n; i++)
        order.push_back(make_pair(-e[i], i));
    // 간단하게 역순 정렬을 하기 위해 부호를 뒤집어서 넣는다

    sort(order.begin(), order.end());
    // 먹는데 걸리는 시간 기준으로 역순 정렬했다 (= 내림차순 정렬, 즉 큰값->작은값 순)

    // 도시락을 데우고 먹을 순서를 정했으므로, 해당 순서 그대로 시뮬레이션한다
    int total_time = 0;
    int beginEat = 0;
    for (int i = 0; i < n; i++)
    {
        int box = order[i].second;
        beginEat += m[box];
        total_time = max(total_time, beginEat + e[box]);
        // 데우고 먹는 시간 계산 (이전 도시락을 다 먹는데 걸리는 시간이 더 큰 경우 그쪽을 총 시간으로 둬야한다)
    }
    return (total_time);
}