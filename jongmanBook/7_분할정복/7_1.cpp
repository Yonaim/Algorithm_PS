// 7.1 1부터 n까지의 합을 구하는 분할 정복 알고리즘

/*
1부터 n까지의 합을 구할 때 정직하게 n-1번 더해나가지 않고 분할정복을 통해 구해본다.

우선 1~n까지의 숫자를 두 개의 숫자 묶음 1~(n/2), (n/2)~n으로 나눈다. (n이 짝수인 상황만을 생각한다)
S(a, b) = a에서 b까지의 합이라고 했을 때,
	-> S(1,n) = S(1,n/2) + S(n/2,n)

이때 S(n/2,n)의 각 항을 순서대로 나열해보면 (n/2+1), (n/2+2), ... (n/2+n/2)
과 같은 꼴을 취하고 있다. 각 항에 공통적으로 n/2가 더해져있으며, 항의 개수는 총 n/2개가 된다.
따라서 S(n/2,n) = (n/2 * n/2) + S(1,n/2)이다.

S(1,n)	= S(1,n/2) + S(n/2,n)
		= S(1,n/2) + (n/2 * n/2) + S(1,n/2)
		= 2 * S(1,n/2) + (n/2 * n/2)
		= 2 * S(1,n/2) + n^2/4

정리된 식을 사용하여 1부터 n까지의 합을 분할정복을 통해 구할 수 있다.
한 문제를 반으로 쪼갰다는게 핵심이다.

base case: n = 1일때, 1
*/

int fastSum(int n)
{
	if (n == 1)
		return (1);
	
	if (n % 2 == 1)
		return (fastSum(n - 1) + n);
	// dp를 사용하지 않기 때문에, 비슷한 크기의 문제로 나누는 것보다는
	// 한 조각과 나머지로 나누는 편이 더 연산량이 적다
	else
		return (2 * (fastSum(n / 2)) + (n * n) / 4);
}

#include <stdio.h>

int main()
{
	printf("%d", fastSum(10));
}