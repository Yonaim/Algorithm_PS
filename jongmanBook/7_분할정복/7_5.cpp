// 7.5 쿼드 트리 압축을 해제하는 재귀 호출 알고리즘

/*
쿼드 트리로 압축된 흑백 그림이 주어지고, 이 그림을 '상하로 뒤집은' 그림을 쿼드 트리 압축해서 출력하는 것이 목적이다.

- 원본 그림을 쿼드 트리로 압축하는 과정은 재귀적으로 이루어진다.
- 주어진 그림은 압축된 버전이다.
    가장 간단하게 생각하면 압축을 풀어 원본을 만들고 그걸 뒤집어 다시 압축하면 될 것 같은데,
    원본 그림의 크기만큼의 공간이 있어야한다. 근데 2^20 * 2^20이면....제한을 넘는다
*/

/*
이렇게 단순 무식하고 확실한 방법이 있지만 시간, 공간적 제한으로 인해 사용할 수 없는 경우에는 어떻게 해야할끼?

    1. 단순 무식한 방법은 포기하고 처음부터 새로 생각한다.
        (=큰 크기의 입력에 대해서도 유효한 방법을 새로 생각)
    2. 이 단순 무식한 방법을 채택하되, 최적화한다.
        (=작은 크기의 입력에 대해서 유효한 방법을 최적화)

둘 중 더 쉬운 것은 2번('단순 무식한 방식 최적화하기')이다.

그래서 이 문제에서도 일단은 압축을 푸는 함수를 만들어본다.
*/

/*
문자열 s의 압축을 해제해 N*N 크기의 배열에 저장하는 함수

base case:
    문자열 s가 나타내는 그림이 완전히 한 색으로만 덮인 경우
    (=첫 글자가 x가 아님)

기저 사례가 아닌 경우 이 그림이 4분할 되어있다는 의미이므로 4개로 쪼개 재귀 호출한다.
배열의 어느 부분에 저장할지, 그리고 이 그림의 크기가 어떻게 되는지도 인자로 보내야할 것이다
*/

#include <string>

using namespace std;

const int MAX_SIZE = 100;
char picture[MAX_SIZE][MAX_SIZE];

/*
4개로 쪼개 재귀 호출할 때, s를 어떻게 쪼개야할까??

단순하게 생각하기로는 적절하게 4분할하여 각각 호출시키면 될 것 같다.
물론 그래도 될 것이다.

근데 재귀 호출을 하며 DFS 탐색하는 과정을 생각해보자.
세부 케이스(작은 그림들)에 대해 깊숙히 탐색을 다 마치고 난 다음에야 다시 위로 올라와 다음의 큰 그림을 탐색하기 시작한다.
그러면, 전체 문자열 s에 대해서 어차피 처음부터 끝까지, 한 자 한 자 순서대로 확인을 하게 된다.

따라서 문자열을 4분할하여 자르지 않고 포인터를 사용해 탐색을 하며 한 자씩 넘기도록 해도 된다!
    -> string의 iterator(반복자)를 사용한다...
        일반 포인터를 사용한다고 하면 '포인터를 움직이는'거니까 포인터의 포인터를 사용해야할 것 같은데 cpp에서는
반복자의 레퍼런스(참조자)를 사용하면 된다?
*/
void decompress(string::iterator &it, int x, int y, int size)
{
	// 딱 한 자만을 확인하고 넘긴다
    char head = *it;
	it++;

	// base case
    if (head == 'b' || head == 'w')
    {
        for (int dy = 0; dy < size; dy++)
            for (int dx = 0; dx < size; dx++)
                picture[y + dy][x + dx] = head;
    }

	int half = size / 2;
	decompress(it, x, y, half);               // 왼쪽 위
	decompress(it, x + half, y, half);        // 오른쪽 위
	decompress(it, x, y + half, half);        // 왼쪽 아래
	decompress(it, x + half, y + half, half); // 오른쪽 아래
}
