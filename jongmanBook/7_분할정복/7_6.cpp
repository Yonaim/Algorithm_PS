// 7.6 쿼드 트리 상하로 뒤집기 문제를 해결하는 분할 정복 알고리즘

/*
우리가 원하는 건 주어진 그림을 상하로 뒤집은 그림을 '압축한 결과'이다. 결국에는 문자열로 출력하면 된다.
이 점을 이용해 메모리 제한을 극복하면 될 것이다. 근데 어떻게???

압축을 해제하는 함수 decompress(7.4)를 생각해본다.
현재 문자열의 시작 문자가 'x'가 아니었으면('b'거나 'w'였으면) 이 문자열이 가리키는 전체 그림의 색이 같다는 의미였다.
상하로 뒤집은 그림을 압축했을 때도 비슷하게 생각해볼 수 있는데, 전체 그림의 색이 같다면 상하로 뒤집었을 때도 똑같다.
주어진 문자열을 사용해 상하로 뒤집은 그림을 압축한 문자열을 바로 출력하고자 할 때 이를 이용할 수 있다. (base case로
삼으면 된다)
*/

/*

1  2
3  4

원래 그림이 다음과 같은 4조각으로 이루어져 있었다고 할 때,

3  4
1  2

위처럼 배치하면 전체적으로 상하가 뒤바뀐 효과를 낼 수 있다....

텍스트로 표현한다는 한계로 인해 저리 표현되었지만(정확한 그림은 194p 참고), 한 조각에 속해 있는 안쪽 그림들에 대해서도
같은 과정을 반복하게 된다는 점을 상기시켜보자. 단 한 조각이 완전히 상하로 뒤집혀 질때까지(=상하로 뒤집었을 때도 같아지는
base case에 도달할 때까지)이 과정이 반복된다. 따라서 각 조각에 대해서 완벽하게 상하 뒤집어진 상태로 저리 배치되게 된다.
*/

/* 난 바보다
솔직히 194페이지 아이디어가 잘 이해가 안된다...
각각을 상하로 뒤집은 결과를 갖다가 위 아래 조각끼리 교체하면 전체적으로 상하좌우가 뒤바뀐 효과를 낸다?
보면 알겠긴 하겠는데...이걸 대체 어떻게 떠올리지?ㅠㅠ

아 미치겠네 상하좌우로 뒤집힌 그림이 아니라 상하로 뒤집힌 그림이었다...문제를 잘 좀 읽자 아오 ㅋㅋㅋㅋㅋㅋ
*/

#include <string>

using namespace std;

// 현재 그림에 대해 완벽하게 상하로 뒤집힌 그림을 압축한 string을 반환
string reverse(string::iterator &it)
{
    char head = *it;
    it++;

    if (head == 'b' || head == 'w')
        return string(1, head);

    string upperLeft = reverse(it);
    string upperRight = reverse(it);
    string lowerLeft = reverse(it);
    string lowerRight = reverse(it);

    return (string("x") + lowerLeft + lowerRight + upperLeft + upperRight);
}
/*
우와 코드가 정말 깔끔하다....
잘 짠 탑-다운 재귀 코드는 명확한 논리를 가지고 간단 명료하게 컴퓨터한테 일을 시키는 느낌이구나.
*/


/*
근데 그래서 이 코드는 

    1. 단순 무식한 방법은 포기하고 처음부터 새로 생각한다.
        (=큰 크기의 입력에 대해서도 유효한 방법을 새로 생각)
    2. 이 단순 무식한 방법을 채택하되, 최적화한다.
        (=작은 크기의 입력에 대해서 유효한 방법을 최적화)

둘 중 2번이라고 생각하면 되나?
단순 무식한 '압축 전부 풀고 재압축하기'라는 방법에서 압축을 풀 때의 아이디어를 갖다가 사용했으니까...?
내가 처음에 생각한 최적화랑은 좀 다르긴 한데...이런 느낌이구나. 아이디어 일부 차용하기?
*/
