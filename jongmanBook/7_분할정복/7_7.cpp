// 7.7 울타리 잘라내기 문제를 해결하는 O(n^2) 알고리즘

/*
가장 단순하게 생각하기로는 가능한 직사각형들을 모두 살피면 될 것 같다.

-> 시작 판자와 끝 판자를 결정하고,
    (시작~끝 판자들 중 가장 작은 판자의 높이) * (시작 판자와 끝 판자의 거리) = (직사각형의 넓이)

이렇게 직사각형의 넓이를 구하면,
판자가 총 N개라고 했을 때 넓이를 구해야하는 직사각형의 개수는 N * (N - 1)개.

'시작 판자'와 '끝 판자'를 결정하기 위해 2중 반복문 사용. 시간 복잡도는 O(n^2)이 된다.
근데 이는 시간 초과가 날 만한 시간복잡도이다...
*/

#include <string>
#include <vector>

using namespace std;

#define min(a, b) (((a) < (b)) ? (a) : (b))

// 판자의 높이를 담은 배열 h[]가 주어질 때 직사각형의 최대 넓이를 반환한다.
int bruteForce(const vector<int> &h)
{
    int ret = 0;
    int N = h.size();

    for (int start = 0; start < N; start++)
    {
        int minHeight = h[start];
        // 시작 판자가 start번째 판자일 때, 가장 큰 직사각형의 넓이를 ret에 저장한다
        for (int end = start; end < N; end++)
        {
            minHeight = min(minHeight, h[end]);
            // 시작 판자가 고정되어있는 상태이므로, 끝 판자를 하나씩 뒤로 옮길때마다 minHeight값은 유지되거나 혹은
            // 작아질 수밖에 없다.
            ret = max(ret, (end - start + 1) * minHeight);
        }
    }
    return (ret);
}

/*
혹시 dp로는 풀 수 없을까? 잠깐 생각해봤는데...

- '시작 판자를 하나 뒤의 것으로 옮기거나 끝 판자를 하나 뒤의 것으로 옮겼을 때 가장 큰 직사각형의 넓이'는 
	'옮기지 않았을 때 가능했던 가장 큰 직사각형의 넓이'와 값의 직접적인 상관관계가 없다. (=이거는 저장해서 재사용 못함)
	- 가능한 직사각형의 가장 높은 높이(=처음~끝 판자 높이들 중 가장 낮은 높이)는 이전 것을 이용할 수도 있겠다만...이미 재사용하고 있다
		(*그리고 이건 어차피 '확인해야하는 케이스'의 개수를 줄여주지는 않는다.
		이전 값을 재사용하긴 하되, 해당 케이스의 답을 구하기 위해선 그 값을 활용한 연산이 필요하다는 뜻)

결론적으로, 재사용할 수 있는 부분이 존재하긴 하나 '한 케이스의 해답을 구하는 연산'에서 이를 재사용할 수 있는 것이지 해당 케이스의 해답이 이전에 저장된 값으로 완전히 대체할 수 있는 것이 아니다.
즉 dp의 메모이제이션은 이용할 수 없다.

=> 이 문제 상황에서 가능한 모든 상황을 탐색하고자 할때 메모이제이션을 통해 '구해야하는 케이스(N^2개)의 수를 줄일 수 없'으며, 
	모든 상황을 탐색하려면 빨라도 O(n^2)인 알고리즘을 사용해야한다.
*/