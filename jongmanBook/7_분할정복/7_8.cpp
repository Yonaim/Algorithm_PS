// 7.8 울타리 잘라내기 문제를 해결하는 분할 정복 알고리즘

/*
우리의 과제: 가장 큰 직사각형의 넓이 구하기.

이를 분할 정복으로 풀기 위해 문제를 절반으로 나눈다. 
단 절반으로 나눠서 '왼쪽 부분 문제'와 '오른쪽 부분 문제'로 나눴을 때 고려해야하는 답이 있다.
바로 왼쪽 부분 문제와 오른쪽 부분 문제 둘에 가장 큰 직사각형이 걸쳐있을 경우이다.

	1. 가장 큰 직사각형은 왼쪽 부분 문제에 있다
	2. 가장 큰 직사각형은 오른쪽 부분 문제에 있다
	3. 가장 큰 직사각형은 왼쪽, 오른쪽 부분 문제 모두에 걸쳐 있다

3가지 중 가장 큰 값을 리턴하면 될 것이다.
생각을 해보면, 부분 문제의 base case는 판자의 개수가 단 하나만 남았을 때이므로
일반적인 상황이라면(해답 직사각형을 이루는 판자의 개수가 2개 이상이라면) 결국에 왼쪽 부분 문제와 오른쪽 부분 문제 둘에 답이 걸쳐있는 케이스가 선정될 것이다

base case:
	판자의 개수 = 1

1, 2는 재귀 호출하면 되고 3은 주어진 상황에서 직접 구해야한다.
(사실 재귀 호출된 1, 2도 결국에 내부적으로 3의 상황을 구하게 될 것이다.
앞서 언급한대로 일반적인 상황이라면 3이 리턴되어버리겠지...결국 3이 이 문제의 핵심이다)
*/


/*
그래서  '3. 가장 큰 직사각형은 왼쪽, 오른쪽 부분 문제 모두에 걸쳐 있다'
이때의 가장 큰 직사각형 넓이는 어떻게 구할 수 있을까?

일단 왼쪽, 오른쪽 부분 문제 모두에 걸쳐있으므로, 왼쪽 오른쪽 부분 문제의 경계를 기준으로 좌, 우 판자는 무조건 포함한다.
(즉 왼쪽 부분 문제의 가장 오른쪽 판자 + 오른쪽 부분 문제의 가장 왼쪽 판자)

이 두 개의 판자부터 시작해, 좌측 판자를 선택할지 우측 판자를 선택할지를 결정해야한다.

	- 좌 우 어떤 판자를 선택하든 증가하는 너비는 같다. 높이만 다르다.
	- 판자를 확장할 때마다 '가능한 직사각형'의 높이는 낮아지거나, 아무리 잘해도 현상유지를 할 뿐이다.

따라서 직사각형의 넓이가 최대가 되도록 하려면, 매 선택에서 좌우 판자 둘 중 더 높은 판자를 선택하면 될 것이다!
	(만약 좌우 판자의 높이가 둘다 현재 직사각형 높이보다 높은 경우, 
	둘 중 어떤 것을 선택하든 '직사각형의 높이' 자체는 현상 유지겠지만, 
	이후 선택에서의 '가능한 직사각형 높이의 범위'에 영향을 미친다; 
	그래서 가능한 매 상황에서 높은 판자를 선택해주어야하는 것이다.)

언제까지 이 결정을 반복해야하는가??....
난 처음에 맨 끝까지 도달하지 않아도 된다고 생각했다.
근데 직사각형의 넓이를 결정하는 요인은 높이만 있는 것이 아니라 너비도 있다. 판자를 확장할 때마다 너비는 1씩 증가한다는 사실을 간과한 것이다!!...
무튼 높이는 낮은데 너비가 매우 길어서 넓이 값이 큰 경우가 있을 수 있다.
따라서 좌우 모두 맨 끝까지 도달하기 이전 케이스들의 값을 모두 구해봐야한다.

(근데.........언뜻보면 논리적인 것 같기도 하지만 왠지 야매스러운 느낌도 나지 않는가?? 그래서 아래 정당성 증명이 있다)
*/

// 뭔가 그리디(gready)의 느낌이 나기도 한다. 밑에 정당성 증명도 그렇고 말이다...

/*
이렇게 분할정복으로 구하면 정말로 시간복잡도가 줄어들까?

3번 상황만 생각해보자.
현재 살피려는 구간의 판자의 개수가 n개라고 했을 때, 가능한 직사각형의 너비 범위는 2~n이므로 구해야하는 케이스의 개수는 n개가 된다.

1,2번 상황의 경우는 구간을 반으로 나눠 재귀호출하게 되므로,
시간복잡도는 결국 (재귀호출 횟수) * (3번 상황을 구하는데 드는 시간)이 된다.
반씩 나눠 재귀호출하므로 재귀호출의 횟수는 log2n이다.

따라서 시간복잡도는 대강 O(logn * n)이 되고, 이는 O(n^2)보다 빠르다
*/


#include <string>
#include <vector>

using namespace std;

#define max(a,b)  (((a) > (b)) ? (a) : (b))
#define min(a,b)  (((a) < (b)) ? (a) : (b))


vector<int> h;

// h[left..right] 구간에서 찾아낼 수 있는 가장 큰 직사각형의 넓이를 반환
int solve(int left, int right)
{
	// base case: 판자가 단 하나
	if (left == right)
		return h[left];

	// [left, mid], [mid + 1, right] 두 구간으로 나눠 문제를 해결
	int mid = (left + right) / 2;
	int ret;

	// 1, 2번 케이스 (좌, 우 구간 각각만 살피기)
	ret = max(solve(left, mid), solve(mid + 1, right));

	// 3번 케이스 (좌, 우 구간에 걸쳐있는 직사각형들 중 가장 큰 것을 찾기)
	
	int lPick = mid;
	int rPick = mid + 1;
	int height = min(h[lPick], h[rPick]);
	ret = max(ret, 2 * height);

	// 양끝에 도달할 때까지 좌, 우 판자 중 매번 더 큰 것을 선택한다
	while (lPick > left || rPick < right)
	{
		if ((rPick < right && lPick == left)
			|| (rPick < right && h[rPick + 1] > h[lPick - 1]))
			{
				// 오른쪽 판자 선택
				rPick++;
				height = min(height, h[rPick]);
			}
		else
		{
			// 왼쪽 판자 선택
			lPick++;
			height = min(height, h[lPick]);
		}

		// 선택 후 직사각형의 넓이를 구해준다
		ret = max(ret, (rPick - lPick + 1) * height);
	}
	return (ret);
}


/*
	가정: '맨 끝에 도달할 때까지 매 선택의 순간 더 높은 판자를 선택하면, 가장 넓은 직사각형이 그 케이스 안에 포함될 것이다'
		...라는 가정의 정당성 증명?

-> 귀류법을 사용해 증명할 수 있다. (=가정과 모순되어야 하는 어떠한 주장이 참이라고 가정한 후 전제와 모순됨을 보이기)

	거짓되어야만 하는 주장: '우리가 찾은 최대 직사각형 R1보다 더 넓은 어떤 사각형 R2가 존재한다'

우리가 찾는 방식을 떠올려보자. 매 순간 더 높은 판자를 선택하고, 양쪽 끝에 도달할 때까지 이 선택이 반복된다.
따라서 전체 구간의 너비가 n이라고 했을 때, 넓이를 구해 답으로 고려하게되는 직사각형의 너비 범위는 2~n이 된다.
전체 구간 너비가 n이므로 R2의 너비도 2~n 중 하나이다.
너비가 같을 때는 높이가 더 높으면 더 넓은 직사각형이므로, 위 주장이 옳다면
우리가 답으로 고려하는 'R2와 너비가 같은 어떠한 직사각형'의 높이는 R2의 높이보다 작아야한다

근데...우리는 맨 끝에 도달할 때까지 매 선택의 순간 더 높은 판자를 선택하고 있다.
그래서 'R2와 너비가 같은 어떠한 직사각형'의 높이가 R2의 높이보다 무조건 같거나 높을 수밖에 없다.

따라서 저건 틀린 주장이고, 처음의 가정이 옳다.
*/
