// 8.17 삼각형 위의 최대 경로의 수를 찾는 동적 계획법 알고리즘

/*
예제 코드 8.8과 같은 문제인데 이번에는 '최대 합을 갖는 경로의 수'를 구해야한다.
즉 '최적의 해'를 갖는 '경우의 수'를 구한다.

이런 문제는,
    1. 먼저 '최적의 해'를 구하기 위한 문제를 풀고,
    2. '최적의 해'를 갖는 '부분 문제의 수'를 구해야한다.

'최적의 해'를 갖는 '부분 문제의 수'를 구하는 과정도 '최적의 해'를 구하는 과정과 비슷하다.
똑같이 Top-down으로 가되, 최적의 해를 갖는 부분 문제로만 향하면 된다.
(물론, 해당 부분문제에 속한 바로 밑단의 여러 부분문제들이 같은 최적의 해를 갖는 경우는
해당되는 부분문제들에 대해 모두 그 내부 부분문제의 수를 구해야할 것이다.)

이 문제의 경우

    count(x, y): (x, y)에서 시작해 맨 아래줄까지 내려가는 최적의 해를 갖는 경로의 수(부분문제의 수)
라고 한다면,

    - (x, y+1)에서의 최적의 해
    - (x+1, y+1)에서의 최적의 해

둘 중 어느 해가 더 최적이냐에 따라

    - (x, y+1)부터의 부분문제 수만을 구할지,
    - (x+1, y+1)부터의 부분문제 수만을 구할지,
    - 혹은 둘다 구해서 더할지

가 결정된다.
*/

/*
그리고 경우의 수를 구할때도 마찬가지로 dp를 사용할 수 있다.

이 문제의 경우 특정한 자리 (i, j)에 대해서 (i-1, j-1) 그리고 (i, j-1) 둘다가 접근할 수 있다.
위에서도 보았다시피, 어떤 큰 부분문제의 수를 구할때 그 바로 아래 밑단의 부분문제들이 '같은 최적의 해'를 갖는 경우에는
그 부분문제들의 경우의 수를 전부 탐색해야하고, 내부 부분문제들이 겹치게 된다.
(다만, 내부 부분문제가 겹치더라도 해당 내부 부분문제까지 도달하기까지의 과정이 다르므로 당연히 다른 경우로 취급한다)

이는 최적의 해를 구하기 위한 문제 풀이에서도 재사용했던 부분이다. 똑같이 생각하면 된다.
*/

int countCache[100][100];
int n;

int count(int y, int x)
{
    if (y == n - 1)
        return (1);

    int &ret = countCache[y][x];
	if (ret != -1)
		return (ret);
	
	ret = 0;
	if (path2(y+1, x+1) >= (path2(y+1, x)))
		ret += count(y+1, x+1);
	if (path2(y+1, x+1) <= (path2(y+1, x)))
		ret += count(y+1, x);
	return (ret)
}