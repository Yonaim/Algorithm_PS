// 8.18 우물을 기어오르는 달팽이 문제를 해결하는 동적 계획법 알고리즘

/*
사실?? 이 문제를 처음 봤을 때
'm일 중 적어도 n-m일이 맑은 날인 경우일 확률'을 구하는 거고, 모든 경우의 수는 확률이 같으니까
    (m일 중 n-m ~ m일이 맑은 날인 경우) / (모든 경우의 수)
        = (mCn-m ~ mCn)의 합 / 2^m
...으로 구하면 되지 않을까 했다. (시그마를 못 적어서 걍 저렇게 적었는데...오른쪽 수가 1씩 증가하는 거임)

근데 이건 수학 문제가 아님~~.....
*/

/*
왜 여기서는 지금까지 지나온 날짜 수, 원소의 합을 둘다 부분문제의 정의에 넣어야하는가??

    - 지나온 날짜 수: 탐색의 끝을 판별
    - 지금까지 원소의 합: 최종적으로 조건을 만족하는지 판별

착각하면 안되는게 최적의 해를 갖는 경우만 구하는게 아니다.
'조건을 만족하는' 모든 경우의 수를 구해야한다.

경우의 수를 구하는데 있어 단 하나의 선택지라도 다르다면 다른 경로이므로,
지금까지 지나온 경로에 대한 정보가 있어야한다.

이 문제에서는 '지나온 날짜 수' 그리고 '지금까지의 원소의 합' 이 두 정보가 같다면
그 아래 부분문제의 경우의 수를 재사용할 수 있으므로 위 두 정보를 부분문제의 정의에 넣고 있는 것이다.
*/

/*
바로 직전에 나왔던 '8.17 삼각형 위의 최대 경로' 문제와 비교해서 생각해보겠다.

삼각형 문제에서 구해야했던 것은 '최적의 해를 갖는 모든 경로의 수'를 구하는 것이었다.
최적의 해가 값이 뭔데??? 이렇게 부분문제의 상세한 값 조건이 문제만 보고는 뭔지 알 수 없는 상황이었다.
그래서 우선 전체적으로 최적의 해를 먼저 구해놨어야 했다.
문제에서 요구하는대로, 상윗단에서 시작하여 최적의 해를 계속 따라가야 했었기 때문에.

그러나 이 문제에서는 최적의 해를 갖는 경우를 탐색하라고 요구하지 않는다.
대신 '총 합이 n 이상일 것' 이 조건을 만족하는 모든 경우의 수를 구하라고 한다.
그래서 삼각형 문제와는 달리 먼저 최적의 해를 구하는 과정이 필요 없었던 것이다.

대신 모든 부분문제들을 탐색하며 그 경우의 수를 구한다.
*/

int n, m;
int cache[MAX_N][2 * MAX_N + 1];

// 지금까지 만든 날씨 조합의 크기가 days이고 그 원소들의 합이 climbed일 때,
// 앞으로 원소들을 더 선택해서 원소의 합이 n 이상이 되게 하는 경우의 수
	// 반환되는 값이 '경우의 수'이므로, 나중에 확률을 구하기 위해서는 전체 경우의 수로 나눠주어야한다
int climb(int days, int climbed)
{
    if (days == m)
        return (climbed >= n ? 1 : 0);

    int &ret = cache[days][climbed];
    if (ret != -1)
        return (ret);

    return (ret = 
			climb(days + 1, climbed + 1)
			+ climb(days + 1, climbed + 2));
}

// 예제: 장마가 찾아왔다

/*
각 조합의 확률이 다른 경우에는 위처럼 단순하게

	(경우의 수) / (경우의 수)

로 확률을 구할 수 없다.
대신 확률을 곱해 바로 확률로 구해야한다. 자세한 건 258p 참조
*/

/*
<경우의 수 계산하기 레시피>

	1. 모든 답을 직접 만들어서 세보는 '완전 탐색 알고리즘'을 설계한다. 
		이때 경우의 수를 제대로 새기 위해서는 재귀 호출의 각 단계에서 고르는 각 선택지에 다음 속성들이 성립해야한다
		- 모든 경우는 이 선택지들에 포함됨
		- 어떤 경우도 두 개 이상의 선택지에 포함되지 않음 (겹치지 않음)

	2. 이전 조각에서 결정한 요소들에 대한 입력을 없애거나 변형해서 줄인다.
		재귀 함수는 앞으로 남아있는 조각들을 고르는 경우의 수만을 반환해야 한다.

	3. 메모이제이션 적용
	
*/