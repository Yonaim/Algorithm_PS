// 외발뛰기 (JUMPGAME)

/*
무식하게 풀려면 모든 절차를 따라가야하는데, 너무 많다.
무식하게 푸는 방식은 안될 것 같다.

문제는 시작점에서 끝점으로 도달하는 방법이 존재하는지 '확인'하는 것이다.

특정 칸에 도달했을 때, 해당 칸에서 이동할 수 있는 칸들을 재귀적으로 호출해나간다.
우리가 원하는 것은 오직 '끝에 도달할 방법이 *존재*하는지 그 여부'이므로,
함수가 반환히는 값은 '어떤 특정 칸 위에 있을 때 끝에 도달할 수 있는가?(true or false)

근데 현재 특정 칸에 있을 때, 어찌해서 해당 칸에 도달했는지는 상관이 없다.
즉...재사용할 수 있다! 각 부분문제들이, 현재 칸에만 관심있고 이전 맥락들은 상관이 없다. (=참조적 투명성(referential transparency)를 가진다)

dp 문제를 하도 많이 풀어서 그런지, 그리고 이게 dp 예제 문제라는 걸 이미 알고 있어서 그런지 이걸 바로 눈치챌 수 있었지만
dp는 기본적으로 재귀 호출 형태에서 계산량 절감을 위한 테크닉이므로 재귀 호출만으로 먼저 작성한 후 dp를 적용해본다.
*/

// 8.4 외발 뛰기 문제를 해결하는 재귀 호출 알고리즘

/*
	jump(x, y): (x, y)에서부터 맨 마지막 칸까지 도달할 수 있는지 여부(true or false)

	base case:
			- 해당 칸이 존재하지 않는 경우 (게임판 범위를 벗어나는 경우)
				-> false
			- 목적지(끝 칸)에 도달한 경우
				-> true

	jump(x, y)	= (이동할 수 있는 칸들 중 true가 하나라도 있으면 true)
				= jump(x + jumpSize, y) || jump(x, y + jumpSize);
*/

int n, board[100][100];

bool jump(int x, int y)
{
	if (x >= n || y >= n)
		return (false);
	if (x == n - 1 && y == n -1)
		return (true);
	
	int jumpSize = board[x][y];
	return (jump(x + jumpSize, y) || jump(x, y + jumpSize));	
}
